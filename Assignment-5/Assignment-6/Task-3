"""
Task: Age classification using nested if-elif-else conditionals.
This code demonstrates different conditional statement approaches.
"""

def classify_age_nested_if_elif_else(age):
    """
    Method 1: Using nested if-elif-else conditionals
    This is the most explicit and readable approach for complex conditions.
    
    Args:
        age (int): The age to classify
    
    Returns:
        str: Age group classification
    """
    if age < 0:
        return "Invalid age: Age cannot be negative"
    elif age == 0:
        return "Newborn"
    elif age < 2:
        return "Infant"
    elif age < 4:
        return "Toddler"
    elif age < 13:
        return "Child"
    elif age < 18:
        return "Teenager"
    elif age < 65:
        if age < 30:
            return "Young Adult"
        elif age < 45:
            return "Adult"
        else:
            return "Middle-aged Adult"
    elif age < 75:
        return "Senior"
    elif age < 90:
        return "Elderly"
    else:
        return "Very Elderly"


def classify_age_simple_if_elif_else(age):
    """
    Method 2: Using simple if-elif-else (non-nested)
    More straightforward approach without nested conditions.
    
    Args:
        age (int): The age to classify
    
    Returns:
        str: Age group classification
    """
    if age < 0:
        return "Invalid age: Age cannot be negative"
    elif 0 <= age < 2:
        return "Infant"
    elif 2 <= age < 4:
        return "Toddler"
    elif 4 <= age < 13:
        return "Child"
    elif 13 <= age < 18:
        return "Teenager"
    elif 18 <= age < 30:
        return "Young Adult"
    elif 30 <= age < 45:
        return "Adult"
    elif 45 <= age < 65:
        return "Middle-aged Adult"
    elif 65 <= age < 75:
        return "Senior"
    elif 75 <= age < 90:
        return "Elderly"
    else:
        return "Very Elderly"


def classify_age_dictionary(age):
    """
    Method 3: Using dictionary mapping (alternative conditional approach)
    Efficient for mapping ranges to values without explicit conditionals.
    
    Args:
        age (int): The age to classify
    
    Returns:
        str: Age group classification
    """
    if age < 0:
        return "Invalid age: Age cannot be negative"
    
    # Dictionary with age ranges and classifications
    age_ranges = {
        (0, 2): "Infant",
        (2, 4): "Toddler",
        (4, 13): "Child",
        (13, 18): "Teenager",
        (18, 30): "Young Adult",
        (30, 45): "Adult",
        (45, 65): "Middle-aged Adult",
        (65, 75): "Senior",
        (75, 90): "Elderly",
        (90, float('inf')): "Very Elderly"
    }
    
    for (min_age, max_age), classification in age_ranges.items():
        if min_age <= age < max_age:
            return classification
    
    return "Unknown age group"


def classify_age_match_case(age):
    """
    Method 4: Using match-case statement (Python 3.10+)
    Modern Python approach using structural pattern matching.
    
    Args:
        age (int): The age to classify
    
    Returns:
        str: Age group classification
    """
    if age < 0:
        return "Invalid age: Age cannot be negative"
    
    # Using match-case with range matching
    match age:
        case 0:
            return "Newborn"
        case _ if 0 < age < 2:
            return "Infant"
        case _ if 2 <= age < 4:
            return "Toddler"
        case _ if 4 <= age < 13:
            return "Child"
        case _ if 13 <= age < 18:
            return "Teenager"
        case _ if 18 <= age < 30:
            return "Young Adult"
        case _ if 30 <= age < 45:
            return "Adult"
        case _ if 45 <= age < 65:
            return "Middle-aged Adult"
        case _ if 65 <= age < 75:
            return "Senior"
        case _ if 75 <= age < 90:
            return "Elderly"
        case _ if age >= 90:
            return "Very Elderly"
        case _:
            return "Unknown age group"


def classify_age_ternary_operator(age):
    """
    Method 5: Using ternary operators (concise conditional)
    Compact way to write simple conditionals (limited for complex logic).
    
    Args:
        age (int): The age to classify
    
    Returns:
        str: Age group classification
    """
    if age < 0:
        return "Invalid age: Age cannot be negative"
    
    return ("Infant" if age < 2 else
            "Toddler" if age < 4 else
            "Child" if age < 13 else
            "Teenager" if age < 18 else
            "Young Adult" if age < 30 else
            "Adult" if age < 45 else
            "Middle-aged Adult" if age < 65 else
            "Senior" if age < 75 else
            "Elderly" if age < 90 else
            "Very Elderly")


def display_classification(age, method_name, classification_func):
    """Helper function to display classification results."""
    result = classification_func(age)
    print(f"{method_name}: Age {age} → {result}")


# Code Analysis:
"""
ANALYSIS OF THE GENERATED CODE:

1. NESTED IF-ELIF-ELSE (Method 1):
   - Pros: Very explicit, easy to understand logic flow
   - Pros: Allows for nested conditions within age ranges
   - Pros: Can handle complex hierarchical classifications
   - Cons: Can become deeply nested and harder to maintain
   - Best for: Complex conditional logic with hierarchies

2. SIMPLE IF-ELIF-ELSE (Method 2):
   - Pros: Flat structure, easier to read and maintain
   - Pros: Clear sequential checking
   - Pros: No nesting complexity
   - Cons: More repetitive range checks
   - Best for: Simple sequential age classifications

3. DICTIONARY MAPPING (Method 3):
   - Pros: Data-driven approach, easy to modify ranges
   - Pros: Separates logic from data
   - Pros: Can be extended easily
   - Cons: Slightly less readable for simple cases
   - Best for: When age ranges might change frequently

4. MATCH-CASE (Method 4):
   - Pros: Modern Python 3.10+ syntax
   - Pros: Pattern matching capabilities
   - Pros: Clean and readable
   - Cons: Requires Python 3.10+
   - Best for: Modern Python projects

5. TERNARY OPERATOR (Method 5):
   - Pros: Very concise
   - Pros: Single expression
   - Cons: Can be hard to read for complex logic
   - Cons: Difficult to debug
   - Best for: Simple, linear conditionals

COMPARISON:
- Nested if-elif-else: Best for hierarchical classifications
- Simple if-elif-else: Best balance of readability and simplicity
- Dictionary: Best for maintainability and data-driven approaches
- Match-case: Best for modern Python with pattern matching
- Ternary: Best for concise, simple conditionals

CONDITIONAL STATEMENTS EXPLANATION:
- if: Executes code if condition is True
- elif: Checks next condition if previous if/elif was False
- else: Executes if all previous conditions were False
- Nested: Conditions inside other conditions for hierarchical logic
"""


# Main execution
if __name__ == "__main__":
    print("=" * 70)
    print("AGE CLASSIFICATION SYSTEM - CONDITIONAL STATEMENTS DEMONSTRATION")
    print("=" * 70)
    
    # Test cases with different ages
    test_ages = [0, 1, 3, 8, 15, 25, 35, 50, 70, 80, 95, -5]
    
    print("\n--- METHOD 1: Nested If-Elif-Else (Primary Method) ---")
    for age in test_ages:
        display_classification(age, "Nested If-Elif-Else", classify_age_nested_if_elif_else)
    
    print("\n--- METHOD 2: Simple If-Elif-Else (Alternative) ---")
    for age in test_ages[:5]:  # Show first 5 examples
        display_classification(age, "Simple If-Elif-Else", classify_age_simple_if_elif_else)
    
    print("\n--- METHOD 3: Dictionary Mapping (Alternative) ---")
    for age in test_ages[:5]:
        display_classification(age, "Dictionary Mapping", classify_age_dictionary)
    
    print("\n--- METHOD 4: Match-Case Statement (Python 3.10+) ---")
    try:
        for age in test_ages[:5]:
            display_classification(age, "Match-Case", classify_age_match_case)
    except SyntaxError:
        print("Match-Case requires Python 3.10+. Skipping this method.")
    
    print("\n--- METHOD 5: Ternary Operator (Alternative) ---")
    for age in test_ages[:5]:
        display_classification(age, "Ternary Operator", classify_age_ternary_operator)
    
    print("\n" + "=" * 70)
    print("CODE ANALYSIS AND EXPLANATION:")
    print("=" * 70)
    print("""
    CONDITIONAL STATEMENTS USED:
    
    1. NESTED IF-ELIF-ELSE:
       - Primary method as requested
       - Demonstrates hierarchical age classification
       - Shows nested conditions within adult age range
       - Most explicit and readable for complex logic
    
    2. SIMPLE IF-ELIF-ELSE:
       - Non-nested alternative
       - Flat structure for easier maintenance
       - Clear sequential condition checking
    
    3. DICTIONARY MAPPING:
       - Data-driven approach
       - Separates age ranges from logic
       - Easy to modify and extend
    
    4. MATCH-CASE:
       - Modern Python 3.10+ syntax
       - Pattern matching for conditions
       - Clean and expressive
    
    5. TERNARY OPERATOR:
       - Concise conditional expressions
       - Single-line nested conditionals
       - Compact but less readable for complex logic
    
    AGE GROUP CLASSIFICATIONS:
    - Invalid: Age < 0
    - Newborn: Age = 0
    - Infant: 0 < Age < 2
    - Toddler: 2 ≤ Age < 4
    - Child: 4 ≤ Age < 13
    - Teenager: 13 ≤ Age < 18
    - Young Adult: 18 ≤ Age < 30
    - Adult: 30 ≤ Age < 45
    - Middle-aged Adult: 45 ≤ Age < 65
    - Senior: 65 ≤ Age < 75
    - Elderly: 75 ≤ Age < 90
    - Very Elderly: Age ≥ 90
    """)
    
    # Interactive mode
    print("\n" + "=" * 70)
    print("INTERACTIVE MODE - Enter ages to classify (or 'quit' to exit)")
    print("=" * 70)
    
    while True:
        try:
            user_input = input("\nEnter an age to classify: ").strip()
            if user_input.lower() in ['quit', 'exit', 'q']:
                print("Exiting...")
                break
            
            age = int(user_input)
            print(f"\nClassification Results:")
            display_classification(age, "Nested If-Elif-Else", classify_age_nested_if_elif_else)
            
        except ValueError:
            print("Error: Please enter a valid integer age!")
        except KeyboardInterrupt:
            print("\n\nExiting...")
            break
        except Exception as e:
            print(f"An error occurred: {e}")
