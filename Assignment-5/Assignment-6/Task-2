"""
Task: Print the first 10 multiples of a number using loops.
This code demonstrates different loop-based implementations.
"""

def print_multiples_for_loop(number):
    """
    Method 1: Using for loop with range()
    This is the most common and Pythonic approach.
    
    Args:
        number (int): The number to find multiples of
    """
    print(f"\n=== Method 1: For Loop with range() ===")
    print(f"First 10 multiples of {number}:")
    for i in range(1, 11):
        multiple = number * i
        print(f"{number} × {i} = {multiple}")


def print_multiples_while_loop(number):
    """
    Method 2: Using while loop (controlled looping)
    This demonstrates explicit loop control with a counter.
    
    Args:
        number (int): The number to find multiples of
    """
    print(f"\n=== Method 2: While Loop (Controlled Looping) ===")
    print(f"First 10 multiples of {number}:")
    i = 1
    while i <= 10:
        multiple = number * i
        print(f"{number} × {i} = {multiple}")
        i += 1


def print_multiples_list_comprehension(number):
    """
    Method 3: Using list comprehension (Pythonic approach)
    This creates a list first, then prints it.
    
    Args:
        number (int): The number to find multiples of
    """
    print(f"\n=== Method 3: List Comprehension ===")
    print(f"First 10 multiples of {number}:")
    multiples = [number * i for i in range(1, 11)]
    for i, multiple in enumerate(multiples, 1):
        print(f"{number} × {i} = {multiple}")


def print_multiples_enumerate(number):
    """
    Method 4: Using enumerate with range()
    This combines range with enumerate for cleaner code.
    
    Args:
        number (int): The number to find multiples of
    """
    print(f"\n=== Method 4: Enumerate with Range ===")
    print(f"First 10 multiples of {number}:")
    for i, multiple in enumerate(range(number, number * 11, number), 1):
        print(f"{number} × {i} = {multiple}")


# Code Analysis:
"""
ANALYSIS OF THE GENERATED CODE:

1. FOR LOOP (Method 1):
   - Uses range(1, 11) which generates numbers from 1 to 10
   - Most readable and Pythonic
   - Automatic iteration control
   - Best for: Known number of iterations

2. WHILE LOOP (Method 2):
   - Explicit counter initialization (i = 1)
   - Condition check (i <= 10)
   - Manual increment (i += 1)
   - More control over loop execution
   - Best for: Conditional iterations or when loop control is needed

3. LIST COMPREHENSION (Method 3):
   - Creates list in one line
   - More memory usage (stores all values)
   - Functional programming style
   - Best for: When you need the list of values later

4. ENUMERATE (Method 4):
   - Uses range with step parameter
   - More efficient (generates multiples directly)
   - Cleaner when you need index and value
   - Best for: When working with sequences

COMPARISON:
- For loop: Best balance of readability and performance
- While loop: Most control, explicit iteration management
- List comprehension: Most concise, but uses more memory
- Enumerate: Most efficient for large ranges
"""


# Main execution
if __name__ == "__main__":
    # Get number from user
    try:
        num = int(input("Enter a number to find its first 10 multiples: "))
        
        # Display all methods
        print_multiples_for_loop(num)
        print_multiples_while_loop(num)
        print_multiples_list_comprehension(num)
        print_multiples_enumerate(num)
        
        print("\n" + "=" * 50)
        print("CODE ANALYSIS:")
        print("=" * 50)
        print("""
        The code demonstrates 4 different loop-based approaches:
        
        1. For Loop: Simple, readable, most commonly used
        2. While Loop: Controlled looping with explicit counter
        3. List Comprehension: Pythonic one-liner approach
        4. Enumerate: Efficient range-based generation
        
        All methods produce the same output but use different
        looping strategies, demonstrating flexibility in Python.
        """)
        
    except ValueError:
        print("Error: Please enter a valid integer!")
    except Exception as e:
        print(f"An error occurred: {e}")
