"""
Task: Generate sum_to_n() function to calculate sum of first n numbers.
This code demonstrates different loop-based and mathematical approaches.
"""

def sum_to_n_for_loop(n):
    """
    Method 1: Using for loop (iterative approach)
    This is the most straightforward loop-based implementation.
    
    Args:
        n (int): Number of integers to sum (from 1 to n)
    
    Returns:
        int: Sum of first n natural numbers
    """
    if n < 0:
        return 0
    
    total = 0
    for i in range(1, n + 1):
        total += i
    return total


def sum_to_n_while_loop(n):
    """
    Method 2: Using while loop (controlled looping)
    Demonstrates explicit loop control with counter.
    
    Args:
        n (int): Number of integers to sum (from 1 to n)
    
    Returns:
        int: Sum of first n natural numbers
    """
    if n < 0:
        return 0
    
    total = 0
    i = 1
    while i <= n:
        total += i
        i += 1
    return total


def sum_to_n_mathematical_formula(n):
    """
    Method 3: Using mathematical formula (Gauss formula)
    Most efficient approach: n * (n + 1) / 2
    No loop required - O(1) time complexity.
    
    Args:
        n (int): Number of integers to sum (from 1 to n)
    
    Returns:
        int: Sum of first n natural numbers
    """
    if n < 0:
        return 0
    return n * (n + 1) // 2


def sum_to_n_recursion(n, max_depth=500):
    """
    Method 4: Using recursion
    Functional programming approach with base case.
    Note: Limited to max_depth to avoid RecursionError.
    
    Args:
        n (int): Number of integers to sum (from 1 to n)
        max_depth (int): Maximum recursion depth (default: 500)
    
    Returns:
        int: Sum of first n natural numbers
        str: Error message if n exceeds max_depth
    """
    if n <= 0:
        return 0
    if n > max_depth:
        # For large n, return error message instead of recursing
        raise RecursionError(f"n ({n}) exceeds maximum recursion depth ({max_depth}). Use a different method for large values.")
    if n == 1:
        return 1
    return n + sum_to_n_recursion(n - 1, max_depth)


def sum_to_n_builtin_sum(n):
    """
    Method 5: Using built-in sum() function with range()
    Pythonic one-liner approach.
    
    Args:
        n (int): Number of integers to sum (from 1 to n)
    
    Returns:
        int: Sum of first n natural numbers
    """
    if n < 0:
        return 0
    return sum(range(1, n + 1))


def sum_to_n_list_comprehension(n):
    """
    Method 6: Using list comprehension with sum()
    Functional style with list comprehension.
    
    Args:
        n (int): Number of integers to sum (from 1 to n)
    
    Returns:
        int: Sum of first n natural numbers
    """
    if n < 0:
        return 0
    return sum([i for i in range(1, n + 1)])


def sum_to_n_accumulate(n):
    """
    Method 7: Using itertools.accumulate (advanced)
    Functional approach using itertools module.
    
    Args:
        n (int): Number of integers to sum (from 1 to n)
    
    Returns:
        int: Sum of first n natural numbers
    """
    if n <= 0:
        return 0
    
    from itertools import accumulate
    numbers = list(range(1, n + 1))
    accumulated = list(accumulate(numbers))
    return accumulated[-1] if accumulated else 0


def sum_to_n_reduce(n):
    """
    Method 8: Using functools.reduce (functional approach)
    Reduces sequence to single value using addition.
    
    Args:
        n (int): Number of integers to sum (from 1 to n)
    
    Returns:
        int: Sum of first n natural numbers
    """
    if n < 0:
        return 0
    
    from functools import reduce
    from operator import add
    return reduce(add, range(1, n + 1), 0)


def display_result(n, method_name, func, skip_if_too_large=False, max_size=500):
    """
    Helper function to display results.
    
    Args:
        n (int): Number to calculate
        method_name (str): Name of the method
        func: Function to call
        skip_if_too_large (bool): Skip if n is too large
        max_size (int): Maximum size for methods that can't handle large n
    """
    if skip_if_too_large and n > max_size:
        print(f"{method_name:30s} → Skipped (n={n} is too large for this method)")
        return
    
    try:
        result = func(n)
        print(f"{method_name:30s} → Sum of 1 to {n} = {result}")
    except RecursionError as e:
        print(f"{method_name:30s} → Error: Recursion depth exceeded for n={n}. Use n <= {max_size} for this method.")
    except Exception as e:
        print(f"{method_name:30s} → Error: {str(e)}")


# Code Analysis:
"""
ANALYSIS OF THE GENERATED CODE:

1. FOR LOOP (Method 1):
   - Time Complexity: O(n) - Linear time
   - Space Complexity: O(1) - Constant space
   - Pros: Simple, readable, easy to understand
   - Cons: Slower for large n compared to formula
   - Best for: Learning loops, when n is moderate

2. WHILE LOOP (Method 2):
   - Time Complexity: O(n) - Linear time
   - Space Complexity: O(1) - Constant space
   - Pros: Explicit loop control, flexible
   - Cons: Requires manual counter management
   - Best for: When loop control needs customization

3. MATHEMATICAL FORMULA (Method 3):
   - Time Complexity: O(1) - Constant time
   - Space Complexity: O(1) - Constant space
   - Pros: Fastest, most efficient, no iteration
   - Cons: Requires knowledge of formula
   - Best for: Production code, large values of n
   - Formula: n * (n + 1) / 2 (Gauss formula)

4. RECURSION (Method 4):
   - Time Complexity: O(n) - Linear time
   - Space Complexity: O(n) - Stack space for recursion
   - Pros: Elegant, functional style
   - Cons: Stack overflow risk for large n, slower, limited to n <= 500
   - Best for: Small values of n (n <= 500), learning recursion
   - Note: Python's default recursion limit is ~1000, so n > 500 may cause errors

5. BUILT-IN SUM (Method 5):
   - Time Complexity: O(n) - Linear time
   - Space Complexity: O(1) - Constant space (generator)
   - Pros: Pythonic, concise, readable
   - Cons: Slightly slower than manual loop
   - Best for: Quick implementation, Pythonic code

6. LIST COMPREHENSION (Method 6):
   - Time Complexity: O(n) - Linear time
   - Space Complexity: O(n) - Creates list
   - Pros: Functional style, readable
   - Cons: Uses more memory (creates list)
   - Best for: When list is needed, functional style

7. ITERTOOLS.ACCUMULATE (Method 7):
   - Time Complexity: O(n) - Linear time
   - Space Complexity: O(n) - Creates list
   - Pros: Functional, can get partial sums
   - Cons: More complex, uses extra memory
   - Best for: When partial sums are needed

8. FUNCTOOLS.REDUCE (Method 8):
   - Time Complexity: O(n) - Linear time
   - Space Complexity: O(1) - Constant space
   - Pros: Functional programming style
   - Cons: Less readable for simple operations
   - Best for: Functional programming paradigms

COMPARISON SUMMARY:
- Best Performance: Mathematical Formula (O(1))
- Best Readability: For Loop or Built-in Sum
- Best Learning: For Loop or While Loop
- Best Pythonic: Built-in Sum with range()
- Best for Large n: Mathematical Formula

CONTROLLED LOOPING SUGGESTIONS:
1. Use for loop for simple iteration over known range
2. Use while loop when iteration count is uncertain
3. Use mathematical formula for optimal performance
4. Use recursion for small n and functional style
5. Use built-in functions for Pythonic code
"""


# Main execution
if __name__ == "__main__":
    print("=" * 80)
    print("SUM OF FIRST N NUMBERS - CALCULATE SUM FROM 1 TO N")
    print("=" * 80)
    print("\nThis program calculates the sum of first n natural numbers.")
    print("Example: For n=5, it calculates: 1 + 2 + 3 + 4 + 5 = 15")
    print("=" * 80)
    
    # Test cases
    test_values = [5, 10, 100, 1000]
    
    print("\n--- CALCULATING SUM USING DIFFERENT METHODS ---")
    for n in test_values:
        print(f"\nCalculating sum of first {n} numbers (1 to {n}):")
        print("-" * 80)
        display_result(n, "For Loop", sum_to_n_for_loop)
        display_result(n, "While Loop", sum_to_n_while_loop)
        display_result(n, "Mathematical Formula", sum_to_n_mathematical_formula)
        # Skip recursion for large values to avoid RecursionError
        display_result(n, "Recursion", sum_to_n_recursion, skip_if_too_large=True, max_size=500)
        display_result(n, "Built-in Sum()", sum_to_n_builtin_sum)
        display_result(n, "List Comprehension", sum_to_n_list_comprehension)
        display_result(n, "Itertools Accumulate", sum_to_n_accumulate)
        display_result(n, "Functools Reduce", sum_to_n_reduce)
    
    print("\n" + "=" * 80)
    print("PERFORMANCE COMPARISON (n = 10000):")
    print("=" * 80)
    
    import time
    
    n_test = 10000
    methods = [
        ("For Loop", sum_to_n_for_loop),
        ("While Loop", sum_to_n_while_loop),
        ("Mathematical Formula", sum_to_n_mathematical_formula),
        ("Built-in Sum", sum_to_n_builtin_sum),
        ("List Comprehension", sum_to_n_list_comprehension),
        ("Functools Reduce", sum_to_n_reduce)
    ]
    
    for method_name, func in methods:
        start_time = time.time()
        result = func(n_test)
        end_time = time.time()
        elapsed = (end_time - start_time) * 1000  # Convert to milliseconds
        print(f"{method_name:30s} → Result: {result:15d}, Time: {elapsed:.6f} ms")
    
    print("\n" + "=" * 80)
    print("CODE EXPLANATION:")
    print("=" * 80)
    print("""
    FUNCTION: sum_to_n(n)
    PURPOSE: Calculate the sum of first n natural numbers (1 + 2 + 3 + ... + n)
    
    MATHEMATICAL FORMULA (Most Efficient):
    Sum = n × (n + 1) / 2
    Example: For n = 5, Sum = 5 × 6 / 2 = 15
    Verification: 1 + 2 + 3 + 4 + 5 = 15 ✓
    
    LOOP-BASED APPROACHES:
    
    1. FOR LOOP:
       - Iterates from 1 to n
       - Adds each number to total
       - Most intuitive for beginners
    
    2. WHILE LOOP:
       - Uses counter variable
       - Continues until counter > n
       - Demonstrates controlled looping
    
    3. RECURSION:
       - Base case: n = 1 returns 1
       - Recursive case: n + sum_to_n(n-1)
       - Stack-based computation
    
    PYTHONIC APPROACHES:
    
    4. BUILT-IN SUM:
       - Uses sum() with range(1, n+1)
       - Most Pythonic and readable
       - Efficient for most cases
    
    5. LIST COMPREHENSION:
       - Creates list [1, 2, ..., n]
       - Sums the list
       - Functional programming style
    
    ADVANCED APPROACHES:
    
    6. MATHEMATICAL FORMULA:
       - Direct calculation without loops
       - O(1) time complexity
       - Best for production code
    
    7. ITERTOOLS.ACCUMULATE:
       - Creates cumulative sums
       - Returns list of partial sums
       - Useful for progressive calculations
    
    8. FUNCTOOLS.REDUCE:
       - Reduces sequence to single value
       - Functional programming paradigm
       - Applies function cumulatively
    
    TIME COMPLEXITY:
    - Loop-based methods: O(n) - Linear time
    - Mathematical formula: O(1) - Constant time
    - Recursion: O(n) - Linear time (with O(n) space)
    
    SPACE COMPLEXITY:
    - Most methods: O(1) - Constant space
    - Recursion: O(n) - Stack space
    - List comprehension: O(n) - List storage
    
    RECOMMENDATIONS:
    - For learning: Use For Loop or While Loop
    - For production: Use Mathematical Formula
    - For Pythonic code: Use Built-in Sum
    - For functional style: Use Recursion (small n) or Reduce
    """)
    
    # Interactive mode - Calculate sum
    print("\n" + "=" * 80)
    print("INTERACTIVE MODE - CALCULATE SUM OF FIRST N NUMBERS")
    print("=" * 80)
    print("Enter a number n to calculate: 1 + 2 + 3 + ... + n")
    print("\nAvailable calculation methods:")
    print("1. For Loop")
    print("2. While Loop")
    print("3. Mathematical Formula (Recommended - Fastest)")
    print("4. Recursion")
    print("5. Built-in Sum() Function")
    print("6. List Comprehension")
    print("7. All Methods Comparison")
    
    while True:
        try:
            print("\n" + "-" * 80)
            user_input = input("Enter a number n to calculate sum (1 to n) or 'quit' to exit: ").strip()
            
            if user_input.lower() in ['quit', 'exit', 'q']:
                print("Exiting...")
                break
            
            n = int(user_input)
            
            if n < 0:
                print("Please enter a non-negative number!")
                continue
            
            print(f"\nYou want to calculate: 1 + 2 + 3 + ... + {n}")
            method_choice = input("Enter method number (1-7) or press Enter for all: ").strip()
            
            if method_choice == "" or method_choice == "7":
                print(f"\n--- ALL METHODS: Sum of numbers from 1 to {n} ---")
                display_result(n, "For Loop", sum_to_n_for_loop)
                display_result(n, "While Loop", sum_to_n_while_loop)
                display_result(n, "Mathematical Formula", sum_to_n_mathematical_formula)
                # Skip recursion for large values
                display_result(n, "Recursion", sum_to_n_recursion, skip_if_too_large=True, max_size=500)
                display_result(n, "Built-in Sum()", sum_to_n_builtin_sum)
                display_result(n, "List Comprehension", sum_to_n_list_comprehension)
            elif method_choice == "1":
                print(f"\n--- Using For Loop: Sum of 1 to {n} ---")
                display_result(n, "For Loop", sum_to_n_for_loop)
            elif method_choice == "2":
                print(f"\n--- Using While Loop: Sum of 1 to {n} ---")
                display_result(n, "While Loop", sum_to_n_while_loop)
            elif method_choice == "3":
                print(f"\n--- Using Mathematical Formula: Sum of 1 to {n} ---")
                display_result(n, "Mathematical Formula", sum_to_n_mathematical_formula)
            elif method_choice == "4":
                print(f"\n--- Using Recursion: Sum of 1 to {n} ---")
                if n > 500:
                    print(f"Warning: Recursion depth limit is 500. For n={n}, this may cause RecursionError.")
                    confirm = input("Continue anyway? (y/n): ").strip().lower()
                    if confirm != 'y':
                        print("Skipping recursion method.")
                        continue
                display_result(n, "Recursion", sum_to_n_recursion)
            elif method_choice == "5":
                print(f"\n--- Using Built-in Sum(): Sum of 1 to {n} ---")
                display_result(n, "Built-in Sum()", sum_to_n_builtin_sum)
            elif method_choice == "6":
                print(f"\n--- Using List Comprehension: Sum of 1 to {n} ---")
                display_result(n, "List Comprehension", sum_to_n_list_comprehension)
            else:
                print("Invalid choice. Showing Mathematical Formula (recommended):")
                display_result(n, "Mathematical Formula", sum_to_n_mathematical_formula)
            
        except ValueError:
            print("Error: Please enter a valid integer!")
        except RecursionError:
            print("Error: Recursion depth exceeded! Use a smaller number or different method.")
        except KeyboardInterrupt:
            print("\n\nExiting...")
            break
        except Exception as e:
            print(f"An error occurred: {e}")
